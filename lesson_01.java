public class lesson_01 {
    //Полиморфизм и переопределение

    //1) Переопределение метода.
    //Представь, что ты для игры написал класс «Корова». В нем есть много полей и методов.
    //Объекты этого класса могут делать разные вещи: идти, есть, спать.
    //Еще коровы звонят в колокольчик, когда ходят. Допустим, ты реализовал в классе все до мелочей.

    //А тут приходит заказчик проекта и говорит, что хочет выпустить новый уровень игры,
    //где все действия происходят в море, а главным героем будет кит.

    //Ты начал проектировать класс «Кит» и понял, что он лишь немного отличается от класса «Корова».
    //Логика работы обоих классов очень похожа, и ты решил использовать наследование.

    //Класс «Корова» идеально подходит на роль класса-родителя, там есть все необходимые переменные и методы.
    //Достаточно только добавить киту возможность плавать. Но есть проблема: у твоего кита есть ноги, рога и колокольчик.
    //Ведь эта функциональность реализована внутри класса «Корова». Что тут можно сделать?

    //К нам на помощь приходит переопределение (замена) методов. Если мы унаследовали метод, который делает не совсем то,
    //что нужно нам в нашем новом классе, мы можем заменить этот метод на другой.

    //Как же это делается? В нашем классе-потомке мы объявляем такой же метод,
    //как и метод класса родителя, который хотим изменить.
    //Пишем в нем новый код. И все – как будто старого метода в классе-родителе и не было.

    //Вот как это работает:

    //class Cow {                           //Тут определены два класса Cow и Whale. Whale унаследован от Cow.
    //  public void printColor() {
    //    System.out.println("Я - белая");
    //  }
    //
    //  public void printName() {
    //    System.out.println("Я - корова");
    //  }
    //}
    //
    //class Whale extends Cow {             //В классе Whale переопределен метод printName();
    //  public void printName() {
    //    System.out.println("Я - кит");
    //  }
    //}

    //public static void main(String[] args) {  //Данный код выведет на экран надпись «Я – корова»
    //  Cow cow = new Cow();
    //  cow.printName();
    //}

    //public static void main(String[] args) {  //Данный код выведет на экран «Я – кит»
    //  Whale whale = new Whale();
    //  whale.printName();
    //}

    //После наследования класса Cow и переопределения метода printName,
    //класс Whale фактически содержит такие данные и методы:

    //class Whale {                     //Ни о каком старом методе мы и не знаем.
    //  public void printColor() {
    //    System.out.println("Я - белая");
    //  }
    //
    //  public void printName() {
    //    System.out.println("Я - кит");
    //  }
    //}

    //Предположим в классе Cow есть метод printAll, который вызывает два других метода, тогда код будет работать так:

    //class Cow {
    //  public void printAll() {
    //    printColor();
    //    printName();
    //  }
    //
    //  public void printColor() {
    //    System.out.println("Я - белая");
    //  }
    //
    //  public void printName() {
    //    System.out.println("Я - корова");
    //  }
    //}
    //
    //class Whale extends Cow {
    //  public void printName() {
    //    System.out.println("Я - кит");
    //  }
    //}

    //public static void main(String[] args) {
    //  Whale whale = new Whale();
    //  whale.printAll();
    //}
    //На экран будет выведена надпись Я – белая Я – кит

    //Обрати внимание, когда вызываются метод printAll() написанный в классе Cow, у объекта типа Whale,
    //то будет использован метод printName класса Whale, а не Cow.

    //Главное, не в каком классе написан метод, а какой тип (класс) объекта, у которого этот метод вызван.

    //— Наследовать и переопределять можно только нестатические методы.
    //Статические методы не наследуются и, следовательно, не переопределяются.


}

